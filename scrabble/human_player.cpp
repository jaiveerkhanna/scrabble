#include "human_player.h"

#include "exceptions.h"
#include "formatting.h"
#include "move.h"
#include "place_result.h"
#include "rang.h"
#include "tile_kind.h"
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <map>
#include <sstream>
#include <stdexcept>
#include <vector>

using namespace std;

// This method is fully implemented.
inline string& to_upper(string& str) {
    transform(str.begin(), str.end(), str.begin(), ::toupper);
    return str;
}

Move HumanPlayer::get_move(const Board& board, const Dictionary& dictionary) const {
    // TODO: begin your implementation here.
    board.print(cout);
    print_hand(cout);
    string input_move = "";
    cout << "Your move, " << PLAYER_NAME_COLOR << this->get_name() << rang::style::reset << endl;
    cout << "Please enter your move (Pass, Exchange, or Place)" << endl;
    Move player_move;
    while (1) {
        try {
            try {
                getline(cin, input_move);
                player_move = parse_move(input_move);
                if (player_move.kind == MoveKind::PLACE) {
                    PlaceResult result = board.test_place(player_move);
                    if (!result.valid) {
                        throw MoveException(result.error);
                    }
                    // Check all of the words generated by the move
                    for (size_t i = 0; i < result.words.size(); i++) {
                        if (!dictionary.is_word(result.words[i])) {
                            throw MoveException("Move generates invalid word");
                        }
                    }
                }
                // Handles counting duplicates for exchange/place
                if (player_move.kind == MoveKind::EXCHANGE || player_move.kind == MoveKind::PLACE) {
                    if (player_move.tiles.size() > get_hand_size()) {
                        throw MoveException("Trying to use more tiles than hand size");
                    }

                    for (size_t i = 0; i < player_move.tiles.size() - 1; i++) {
                        size_t num_identical_tiles = 1;
                        for (size_t j = i + 1; j < player_move.tiles.size(); j++) {
                            if (player_move.tiles[i] == player_move.tiles[j]) {
                                num_identical_tiles++;
                            }
                        }
                        if (tiles.count_tiles(player_move.tiles[i]) < num_identical_tiles) {
                            throw MoveException("You may only use each tile once!");
                        }
                    }
                }
                break;
            }
            // Catch MoveExceptions and throw appropriate Command Exception with message
            // Implemented as per documentation requirements that MoveExceptions should not print error messages
            catch (MoveException& a) {
                throw CommandException(a.what());
            }
        }
        // Catch all Command Exceptions and prompt user for a new input
        catch (CommandException& b) {
            cerr << "ERROR: " << b.what() << endl;
            cerr << "Please try again:" << endl;
        }
    }
    return player_move;
}

vector<TileKind> HumanPlayer::parse_tiles(string& letters) const {
    // TODO: begin implementation here.
    vector<TileKind> move_tiles;
    for (size_t i = 0; i < letters.length(); i++) {
        // See if the player_hand has the tile, if it doesn't, error will be thrown

        try {
            // Check if player has a tile
            TileKind temp = this->tiles.lookup_tile(letters[i]);
            if (temp.letter == '?') {
                // If it is a ? and doesn't have an assignment, take in the next letter
                if (temp.assigned == '\0') {
                    if (i == letters.length() - 1) {
                        throw MoveException("Player did not specify a character for the ? tile");
                    }
                    temp.assigned = tolower(letters[i + 1]);
                    i++;
                }
            }
            move_tiles.push_back(temp);
        } catch (out_of_range& a) {
            throw MoveException("Player is using a tile they do not have");
        }
    }
    return move_tiles;
}

Move HumanPlayer::parse_move(string& move_string) const {
    // TODO: begin implementation here.
    stringstream is(move_string);
    Move player_move;
    string move_type;
    // cerr << move_string << endl;
    if (is >> move_type) {
        // cerr << move_type << endl;
    } else {
        throw CommandException("Did not specify a move type");
    }
    move_type = to_upper(move_type);
    if (move_type == "PASS") {
        player_move.kind = MoveKind::PASS;
    } else if (move_type == "EXCHANGE") {
        player_move.kind = MoveKind::EXCHANGE;
        // Create tiles using the 10th location onwards (9th is the space after EXCHANGE)
        string tiles_string;
        if (is >> tiles_string) {
        } else {
            throw CommandException("Did not specify valid tiles");
        }
        player_move.tiles = parse_tiles(tiles_string);
    }

    else if (move_type == "PLACE") {
        player_move.kind = MoveKind::PLACE;
        // is.ignore();
        char direction;
        size_t row, column;
        if (is >> direction) {
            if (direction == '|') {
                player_move.direction = Direction::DOWN;
            } else if (direction == '-') {
                player_move.direction = Direction::ACROSS;
            } else {
                throw CommandException("Invalid input for direction");
            }
            // cerr << direction << endl;
        } else {
            // Could not get the direction character
            throw CommandException("Could not get direction");
        }

        if (is >> row >> column) {
            player_move.row = row - 1;
            player_move.column = column - 1;
        } else {
            // could not get row/column
            throw CommandException("Could not get start tile");
        }
        string temp = "";
        if (is >> temp) {

        } else {
            throw CommandException("Did not receive a list of tiles to place");
        }
        // cerr << temp << endl;
        player_move.tiles = parse_tiles(temp);
    } else {
        // No valid input
        throw CommandException("No Valid Input");
    }
    return player_move;
}

// This function is fully implemented.
void HumanPlayer::print_hand(ostream& out) const {
    const size_t tile_count = tiles.count_tiles();
    const size_t empty_tile_count = this->get_hand_size() - tile_count;
    const size_t empty_tile_width = empty_tile_count * (SQUARE_OUTER_WIDTH - 1);

    for (size_t i = 0; i < HAND_TOP_MARGIN - 2; ++i) {
        out << endl;
    }

    out << repeat(SPACE, HAND_LEFT_MARGIN) << FG_COLOR_HEADING << "Your Hand: " << endl << endl;

    // Draw top line
    out << repeat(SPACE, HAND_LEFT_MARGIN) << FG_COLOR_LINE << BG_COLOR_NORMAL_SQUARE;
    print_horizontal(tile_count, L_TOP_LEFT, T_DOWN, L_TOP_RIGHT, out);
    out << repeat(SPACE, empty_tile_width) << BG_COLOR_OUTSIDE_BOARD << endl;

    // Draw middle 3 lines
    for (size_t line = 0; line < SQUARE_INNER_HEIGHT; ++line) {
        out << FG_COLOR_LABEL << BG_COLOR_OUTSIDE_BOARD << repeat(SPACE, HAND_LEFT_MARGIN);
        for (auto it = tiles.cbegin(); it != tiles.cend(); ++it) {
            out << FG_COLOR_LINE << BG_COLOR_NORMAL_SQUARE << I_VERTICAL << BG_COLOR_PLAYER_HAND;

            // Print letter
            if (line == 1) {
                out << repeat(SPACE, 2) << FG_COLOR_LETTER << (char)toupper(it->letter) << repeat(SPACE, 2);

                // Print score in bottom right
            } else if (line == SQUARE_INNER_HEIGHT - 1) {
                out << FG_COLOR_SCORE << repeat(SPACE, SQUARE_INNER_WIDTH - 2) << setw(2) << it->points;

            } else {
                out << repeat(SPACE, SQUARE_INNER_WIDTH);
            }
        }
        if (tiles.count_tiles() > 0) {
            out << FG_COLOR_LINE << BG_COLOR_NORMAL_SQUARE << I_VERTICAL;
            out << repeat(SPACE, empty_tile_width) << BG_COLOR_OUTSIDE_BOARD << endl;
        }
    }

    // Draw bottom line
    out << repeat(SPACE, HAND_LEFT_MARGIN) << FG_COLOR_LINE << BG_COLOR_NORMAL_SQUARE;
    print_horizontal(tile_count, L_BOTTOM_LEFT, T_UP, L_BOTTOM_RIGHT, out);
    out << repeat(SPACE, empty_tile_width) << rang::style::reset << endl;
}
